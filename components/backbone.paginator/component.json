{
  "name": "backbone.paginator",
  "description": "A set of pagination components for Backbone.js",
  "version": "0.1.54",
  "homepage": "http://github.com/addyosmani/backbone.paginator",
  "author": {
    "name": "Addy Osmani",
    "email": "addyosmani@gmail.com",
    "url": "http://addyosmani.com"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/addyosmani/backbone.paginator.git"
  },
  "bugs": {
    "url": "https://github.com/addyosmani/backbone.paginator/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/addyosmani/backbone.paginator/blob/master/LICENSE-MIT"
    }
  ],
  "preferGlobal": true,
  "dependencies": {
    "backbone": "~0.9.2",
    "underscore": "1.3.3"
  },
  "devDependencies": {
    "grunt-mocha": "~0.1.7",
    "grunt": "~0.3.0",
    "backbone": "~0.9.2",
    "underscore": "1.3.3"
  },
  "keywords": [
    "backbone",
    "pagination",
    "paginator"
  ],
  "engines": {
    "node": ">= 0.6.6"
  },
  "main": "lib/backbone.paginator",
  "scripts": {
    "test": "grunt test"
  },
  "readme": "# Backbone.Paginator\n\n[![Continuous Integration status](https://secure.travis-ci.org/addyosmani/backbone.paginator.png)](http://travis-ci.org/addyosmani/backbone.paginator)\n\n![](https://raw.github.com/addyosmani/backbone.paginator/master/media/logo.png)\n\nBackbone.Paginator is a set of opinionated components for paginating collections of data using Backbone.js.\n\n It aims to provide both solutions for assisting with pagination of requests to a server (e.g an API) as well as pagination of single-loads of data, where we may wish to further paginate a collection of N results into M pages within a view.\n\n## Downloads And Source Code\n\nYou can either download the raw source code for the project, fork the repository or use one of these links:\n\n* Production: [production version][min] 10.2K file size (2.79K gzipped)\n* Development: [development version][max] 30.1K file size (6.8K gzipped)\n* Examples: [tarball](https://github.com/addyosmani/backbone.paginator/zipball/)\n\n[min]: https://raw.github.com/addyosmani/backbone.paginator/master/dist/backbone.paginator.min.js\n[max]: https://raw.github.com/addyosmani/backbone.paginator/master/dist/backbone.paginator.js\n\n\n## Paginator's pieces\n\nBackbone.Paginator supports two main pagination components:\n\n* **Backbone.Paginator.requestPager**: For pagination of requests between a client and a server-side API\n* **Backbone.Paginator.clientPager**: For pagination of data returned from a server which you would like to further paginate within the UI (e.g 60 results are returned, paginate into 3 pages of 20)\n\n\n## Live Examples\n\nLive previews of both pagination components using the Netflix API can be found below. Fork the repository to experiment with these examples further.\n\n* [Backbone.Paginator.requestPager()](http://addyosmani.github.com/backbone.paginator/examples/netflix-request-paging/index.html)\n* [Backbone.Paginator.clientPager()](http://addyosmani.github.com/backbone.paginator/examples/netflix-client-paging/index.html)\n* [Infinite Pagination (Backbone.Paginator.requestPager())](http://addyosmani.github.com/backbone.paginator/examples/netflix-infinite-paging/index.html)\n* [Diacritic Plugin](http://addyosmani.github.com/backbone.paginator/examples/google-diacritic/index.html)\n\n##Paginator.requestPager\n\nIn this section we're going to walkthrough actually using the requestPager.\n\n####1. Create a new Paginated collection\nFirst, we define a new Paginated collection using `Backbone.Paginator.requestPager()` as follows:\n\n```javascript\nvar PaginatedCollection = Backbone.Paginator.requestPager.extend({\n```\n####2: Set the model for the collection as normal\n\nWithin our collection, we then (as normal) specify the model to be used with this collection followed by the URL (or base URL) for the service providing our data (e.g the Netflix API).\n\n```javascript\n        model: model,\n```\n####3. Configure the base URL and the type of the request\n\nWe need to set a base URL. The `type` of the request is `GET` by default, and the `dataType` is `jsonp` in order to enable cross-domain requests.\n\n```javascript\n\t\tpaginator_core: {\n\t\t\t// the type of the request (GET by default)\n\t\t\ttype: 'GET',\n\n\t\t\t// the type of reply (jsonp by default)\n\t\t\tdataType: 'jsonp',\n\n\t\t\t// the URL (or base URL) for the service\n\t\t\turl: 'http://odata.netflix.com/Catalog/People(49446)/TitlesActedIn?'\n\t\t},\n```\n\n####4. Configure how the library will show the results\n\nWe need to tell the library how many items per page would we like to see, etc...\n\n```javascript\n\t\tpaginator_ui: {\n\t\t\t// the lowest page index your API allows to be accessed\n\t\t\tfirstPage: 0,\n\n\t\t\t// which page should the paginator start from\n\t\t\t// (also, the actual page the paginator is on)\n\t\t\tcurrentPage: 0,\n\n\t\t\t// how many items per page should be shown\n\t\t\tperPage: 3,\n\n\t\t\t// a default number of total pages to query in case the API or\n\t\t\t// service you are using does not support providing the total\n\t\t\t// number of pages for us.\n\t\t\t// 10 as a default in case your service doesn't return the total\n\t\t\ttotalPages: 10\n\t\t},\n```\n\n####5. Configure the parameters we want to send to the server\n\nOnly the base URL won't be enough for most cases, so you can pass more parameters to the server.\nNote how you can use functions insead of hardcoded values, and you can also reffer to the values you specified in `paginator_ui`.\n\n```javascript\n\t\tserver_api: {\n\t\t\t// the query field in the request\n\t\t\t'$filter': '',\n\n\t\t\t// number of items to return per request/page\n\t\t\t'$top': function() { return this.perPage },\n\n\t\t\t// how many results the request should skip ahead to\n\t\t\t// customize as needed. For the Netflix API, skipping ahead based on\n\t\t\t// page * number of results per page was necessary.\n\t\t\t'$skip': function() { return this.currentPage * this.perPage },\n\n\t\t\t// field to sort by\n\t\t\t'$orderby': 'ReleaseYear',\n\n\t\t\t// what format would you like to request results in?\n\t\t\t'$format': 'json',\n\n\t\t\t// custom parameters\n\t\t\t'$inlinecount': 'allpages',\n\t\t\t'$callback': 'callback'\n\t\t},\n```\n\n####6. Finally, configure Collection.parse() and we're done\n\nThe last thing we need to do is configure our collection's `parse()` method. We want to ensure we're returning the correct part of our JSON response containing the data our collection will be populated with, which below is `response.d.results` (for the Netflix API).\n\nYou might also notice that we're setting `this.totalPages` to the total page count returned by the API. This allows us to define the maximum number of (result) pages available for the current/last request so that we can clearly display this in the UI. It also allows us to infuence whether clicking say, a 'next' button should proceed with a request or not.\n\n```javascript\n        parse: function (response) {\n            // Be sure to change this based on how your results\n            // are structured (e.g d.results is Netflix specific)\n            var tags = response.d.results;\n            //Normally this.totalPages would equal response.d.__count\n            //but as this particular NetFlix request only returns a\n            //total count of items for the search, we divide.\n            this.totalPages = Math.ceil(response.d.__count / this.perPage);\n            return tags;\n        }\n    });\n\n});\n```\n\n####Convenience methods:\n\nFor your convenience, the following methods are made available for use in your views to interact with the `requestPager`:\n\n* **Collection.goTo( n, options )** - go to a specific page\n* **Collection.requestNextPage( options )** - go to the next page\n* **Collection.requestPreviousPage( options )** - go to the previous page\n* **Collection.howManyPer( n )** - set the number of items to display per page\n\n**requestPager** collection's methods `.goTo()`, `.requestNextPage()` and `.requestPreviousPage()` are all extension of the original [Backbone Collection.fetch() method](http://documentcloud.github.com/backbone/#Collection-fetch). As so, they all can take the same option object as parameter.\n\nThis option object can use `success` and `error` parameters to pass a function to be executed after server answer.\n\n```javascript\nCollection.goTo(n, {\n\tsuccess: function( collection, response ) {\n\t\t// called is server request success\n\t},\n\terror: function( collection, response ) {\n\t\t// called if server request fail\n\t}\n});\n```\n\nTo manage callback, you could also use the [jqXHR](http://api.jquery.com/jQuery.ajax/#jqXHR) returned by these methods to manage callback.\n\n```javascript\nCollection\n\t.requestNextPage()\n\t.done(function( data, textStatus, jqXHR ) {\n\t\t// called is server request success\n\t})\n\t.fail(function( data, textStatus, jqXHR ) {\n\t\t// called if server request fail\n\t})\n\t.always(function( data, textStatus, jqXHR ) {\n\t\t// do something after server request is complete\n\t});\n});\n```\n\nIf you'd like to add the incoming models to the current collection, instead of replacing the collection's contents, pass `{add: true}` as an option to these methods.\n\n```javascript\nCollection.requestPreviousPage({ add: true });\n```\n\n##Paginator.clientPager\n\nThe `clientPager` works similar to the `requestPager`, except that our configuration values influence the pagination of data already returned at a UI-level. Whilst not shown (yet) there is also a lot more UI logic that ties in with the `clientPager`. An example of this can be seen in 'views/clientPagination.js'.\n\n####1. Create a new paginated collection with a model and URL\nAs with `requestPager`, let's first create a new Paginated `Backbone.Paginator.clientPager` collection, with a model:\n\n```javascript\n    var PaginatedCollection = Backbone.Paginator.clientPager.extend({\n\n        model: model,\n```\n\n####2. Configure the base URL and the type of the request\n\nWe need to set a base URL. The `type` of the request is `GET` by default, and the `dataType` is `jsonp` in order to enable cross-domain requests.\n\n```javascript\n\t\tpaginator_core: {\n\t\t\t// the type of the request (GET by default)\n\t\t\ttype: 'GET',\n\n\t\t\t// the type of reply (jsonp by default)\n\t\t\tdataType: 'jsonp',\n\n\t\t\t// the URL (or base URL) for the service\n\t\t\turl: 'http://odata.netflix.com/v2/Catalog/Titles?&'\n\t\t},\n```\n\n####3. Configure how the library will show the results\n\nWe need to tell the library how many items per page would we like to see, etc...\n\n```javascript\n\t\tpaginator_ui: {\n\t\t\t// the lowest page index your API allows to be accessed\n\t\t\tfirstPage: 1,\n\n\t\t\t// which page should the paginator start from\n\t\t\t// (also, the actual page the paginator is on)\n\t\t\tcurrentPage: 1,\n\n\t\t\t// how many items per page should be shown\n\t\t\tperPage: 3,\n\n\t\t\t// a default number of total pages to query in case the API or\n\t\t\t// service you are using does not support providing the total\n\t\t\t// number of pages for us.\n\t\t\t// 10 as a default in case your service doesn't return the total\n\t\t\ttotalPages: 10,\n\n\t\t\t// The total number of pages to be shown as a pagination\n\t\t\t// list is calculated by (pagesInRange * 2) + 1.\n\t\t\tpagesInRange: 4\n\t\t},\n```\n\n####4. Configure the parameters we want to send to the server\n\nOnly the base URL won't be enough for most cases, so you can pass more parameters to the server.\nNote how you can use functions insead of hardcoded values, and you can also reffer to the values you specified in `paginator_ui`.\n\n```javascript\n\t\tserver_api: {\n\t\t\t// the query field in the request\n\t\t\t'$filter': 'substringof(\\'america\\',Name)',\n\n\t\t\t// number of items to return per request/page\n\t\t\t'$top': function() { return this.perPage },\n\n\t\t\t// how many results the request should skip ahead to\n\t\t\t// customize as needed. For the Netflix API, skipping ahead based on\n\t\t\t// page * number of results per page was necessary.\n\t\t\t'$skip': function() { return this.currentPage * this.perPage },\n\n\t\t\t// field to sort by\n\t\t\t'$orderby': 'ReleaseYear',\n\n\t\t\t// what format would you like to request results in?\n\t\t\t'$format': 'json',\n\n\t\t\t// custom parameters\n\t\t\t'$inlinecount': 'allpages',\n\t\t\t'$callback': 'callback'\n\t\t},\n```\n\n####5. Finally, configure Collection.parse() and we're done\n\nAnd finally we have our `parse()` method, which in this case isn't concerned with the total number of result pages available on the server as we have our own total count of pages for the paginated data in the UI.\n\n```javascript\n\t\tparse: function (response) {\n            var tags = response.d.results;\n            return tags;\n        }\n\n    });\n```\n\n####Convenience methods:\n\nAs mentioned, your views can hook into a number of convenience methods to navigate around UI-paginated data. For `clientPager` these include:\n\n* **Collection.goTo(n)** - go to a specific page\n* **Collection.previousPage()** - go to the previous page\n* **Collection.nextPage()** - go to the next page\n* **Collection.howManyPer(n)** - set how many items to display per page\n* **Collection.setSort(sortBy, sortDirection)** - update sort on the current view. Sorting will automatically detect if you're trying to sort numbers (even if they're strored as strings) and will do the right thing.\n* **Collection.setFilter(filterFields, filterWords)** - filter the current view. Filtering supports multiple words without any specific order, so you'll basically get a full-text search ability. Also, you can pass it only one field from the model, or you can pass an array with fields and all of them will get filtered. Last option is to pass it an object containing a comparison method and rules. Currently, only ```levenshtein``` method is available.\n\n```javascript\n\tthis.collection.setFilter(\n\t\t{'Name': {cmp_method: 'levenshtein', max_distance: 7}}\n\t\t, \"Amreican P\" // Note the switched 'r' and 'e', and the 'P' from 'Pie'\n\t);\n```\n\nAlso note that the levenshtein plugin should be loaded and enabled using the ```useLevenshteinPlugin``` variable.\nLast but not less important: Performing Levenshtein comparison returns the ```distance``` between to strings. It won't let you *search* lenghty text.\nThe distance between two strings means the number of characters that should be added, removed or moved to the left or to the right so the strings get equal.\nThat means that comparing \"Something\" in \"This is a test that could show something\" will return 32, which is bigger than comparing \"Something\" and \"ABCDEFG\" (9).\nUse levenshtein only for short texts (titles, names, etc).\n\n* **Collection.doFakeFilter(filterFields, filterWords)** - returns the models count after fake-applying a call to ```Collection.setFilter```.\n\n* **Collection.setFieldFilter(rules)** - filter each value of each model according to `rules` that you pass as argument. Example: You have a collection of books with 'release year' and 'author'. You can filter only the books that were released between 1999 and 2003. And then you can add another `rule` that will filter those books only to authors who's name start with 'A'. Possible rules: function, required, min, max, range, minLength, maxLength, rangeLength, oneOf, equalTo, containsAllOf, pattern.  Passing this an empty rules set will remove any FieldFilter rules applied.\n```javascript\n\tmy_collection.setFieldFilter([\n\t\t{field: 'release_year', type: 'range', value: {min: '1999', max: '2003'}},\n\t\t{field: 'author', type: 'pattern', value: new RegExp('A*', 'igm')}\n\t]);\n\n\t//Rules:\n\t//\n\t//var my_var = 'green';\n\t//\n\t//{field: 'color', type: 'equalTo', value: my_var}\n\t//{field: 'color', type: 'function', value: function(field_value){ return field_value == my_var; } }\n\t//{field: 'color', type: 'required'}\n\t//{field: 'number_of_colors', type: 'min', value: '2'}\n\t//{field: 'number_of_colors', type: 'max', value: '4'}\n\t//{field: 'number_of_colors', type: 'range', value: {min: '2', max: '4'} }\n\t//{field: 'color_name', type: 'minLength', value: '4'}\n\t//{field: 'color_name', type: 'maxLength', value: '6'}\n\t//{field: 'color_name', type: 'rangeLength', value: {min: '4', max: '6'}}\n\t//{field: 'color_name', type: 'oneOf', value: ['green', 'yellow']}\n\t//{field: 'color_name', type: 'pattern', value: new RegExp('gre*', 'ig')}\n\t//{field: 'color_name', type: 'containsAllOf', value: ['green', 'yellow', 'blue']}\n```\n\n* **Collection.doFakeFieldFilter(rules)** - returns the models count after fake-applying a call to ```Collection.setFieldFilter```.\n\n####Implementation notes:\n\nYou can use some variables in your ```View``` to represent the actual state of the paginator.\n\n```totalUnfilteredRecords``` - Contains the number of records, including all records filtered in any way. (Only available in ```clientPager```)\n\n```totalRecords``` - Contains the number of records\n\n```currentPage``` - The actual page were the paginator is at.\n\n```perPage``` - The number of records the paginator will show per page.\n\n```totalPages``` - The number of total pages.\n\n```startRecord``` - The position of the first record shown in the current page (eg 41 to 50 from 2000 records) (Only available in ```clientPager```)\n\n```endRecord``` - The position of the last record shown in the current page (eg 41 to 50 from 2000 records) (Only available in ```clientPager```)\n\n```pagesInRange``` - The number of pages to be drawn on each side of the current page. So if pagesInRange is 3 and current page is 13 you will get\nthe numbers 10, 11, 12, 13(selected), 14, 15, 16.\n\n```html\n<!-- sample template for pagination UI -->\n<script type=\"text/html\" id=\"tmpServerPagination\">\n\n\t<div class=\"row-fluid\">\n\n\t\t<div class=\"pagination span8\">\n\t\t\t<ul>\n\t\t\t\t<% _.each (pageSet, function (p) { %>\n\t\t\t\t<% if (currentPage == p) { %>\n\t\t\t\t\t<li class=\"active\"><span><%= p %></span></li>\n\t\t\t\t<% } else { %>\n\t\t\t\t\t<li><a href=\"#\" class=\"page\"><%= p %></a></li>\n\t\t\t\t<% } %>\n\t\t\t\t<% }); %>\n\t\t\t</ul>\n\t\t</div>\n\n\t\t<div class=\"pagination span4\">\n\t\t\t<ul>\n\t\t\t\t<% if (currentPage > firstPage) { %>\n\t\t\t\t\t<li><a href=\"#\" class=\"serverprevious\">Previous</a></li>\n\t\t\t\t<% }else{ %>\n\t\t\t\t\t<li><span>Previous</span></li>\n\t\t\t\t<% }%>\n\t\t\t\t<% if (currentPage < totalPages) { %>\n\t\t\t\t\t<li><a href=\"#\" class=\"servernext\">Next</a></li>\n\t\t\t\t<% } else { %>\n\t\t\t\t\t<li><span>Next</span></li>\n\t\t\t\t<% } %>\n\t\t\t\t<% if (firstPage != currentPage) { %>\n\t\t\t\t\t<li><a href=\"#\" class=\"serverfirst\">First</a></li>\n\t\t\t\t<% } else { %>\n\t\t\t\t\t<li><span>First</span></li>\n\t\t\t\t<% } %>\n\t\t\t\t<% if (totalPages != currentPage) { %>\n\t\t\t\t\t<li><a href=\"#\" class=\"serverlast\">Last</a></li>\n\t\t\t\t<% } else { %>\n\t\t\t\t\t<li><span>Last</span></li>\n\t\t\t\t<% } %>\n\t\t\t</ul>\n\t\t</div>\n\n\t</div>\n\n\t<span class=\"cell serverhowmany\"> Show <a href=\"#\"\n\t\tclass=\"selected\">18</a> | <a href=\"#\" class=\"\">9</a> | <a href=\"#\" class=\"\">12</a> per page\n\t</span>\n\n\t<span class=\"divider\">/</span>\n\n\t<span class=\"cell first records\">\n\t\tPage: <span class=\"label\"><%= currentPage %></span> of <span class=\"label\"><%= totalPages %></span> shown\n\t</span>\n\n</script>\n```\n\n\n## Plugins\n\n**Diacritic.js**\n\nA plugin for Backbone.Paginator that replaces diacritic characters (`´`, `˝`, `̏`, `˚`,`~` etc.) with characters that match them most closely. This is particularly useful for filtering.\n\nTo enable the plugin, set `this.useDiacriticsPlugin` to true, as can be seen in the example below:\n\n```javascript\nPaginator.clientPager = Backbone.Collection.extend({\n\n\t\t// Default values used when sorting and/or filtering.\n\t\tinitialize: function(){\n\t\t\tthis.useDiacriticsPlugin = true; // use diacritics plugin if available\n\t\t...\n```\n\n## Release History\n\nPlease check CHANGELOG.md for a complete release history/changelog.\n\n## Team\n\n* [Addy Osmani (addyosmani)](http://github.com/addyosmani) - Developer Programs Engineer, Google\n* [Alexander Nestorov (alexandernst)](http://github.com/alexandernst) - Software Developer, EmeIEme\n* [Srinivas Kusunam (skusunam)](http://github.com/skusunam) - Mobile\\Agile Consultant, Liberty Leap Technologies\n\n## Contributing\nIn lieu of a formal styleguide, take care to maintain the existing coding style. Add unit tests for any new or changed functionality. Lint and test your code using [grunt](https://github.com/cowboy/grunt).\n\n_Also, please don't edit files in the \"dist\" subdirectory as they are generated via grunt. You'll find source code in the \"lib\" subdirectory!_\n\n## License\nCopyright (c) 2012 Addy Osmani\nLicensed under the MIT license.\n",
  "_id": "backbone.paginator@0.1.54"
}